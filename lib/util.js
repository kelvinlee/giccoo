// Generated by CoffeeScript 1.6.3
var crypto, decrypt, empty, encrypt, md5, sanitize, xss;

xss = require('xss');

sanitize = require('validator').sanitize;

crypto = require('crypto');

exports.format_date = function(date, friendly) {
  var day, hour, minute, month, mseconds, now, second, thisYear, time_std, year, _ref;
  year = date.getFullYear();
  month = date.getMonth() + 1;
  day = date.getDate();
  hour = date.getHours();
  minute = date.getMinutes();
  second = date.getSeconds();
  if (friendly) {
    now = new Date();
    mseconds = -(date.getTime() - now.getTime());
    time_std = [1000, 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000];
    if (mseconds < time_std[3]) {
      if (mseconds > 0 && mseconds < time_std[1]) {
        return Math.floor(mseconds / time_std[0]).toString() + ' 秒前';
      }
      if (mseconds > time_std[1] && mseconds < time_std[2]) {
        return Math.floor(mseconds / time_std[1]).toString() + ' 分钟前';
      }
      if (mseconds > time_std[2]) {
        return Math.floor(mseconds / time_std[2]).toString() + ' 小时前';
      }
    }
  }
  month = (month < 10 ? '0' : '') + month;
  day = (day < 10 ? '0' : '') + day;
  hour = (hour < 10 ? '0' : '') + hour;
  minute = (minute < 10 ? '0' : '') + minute;
  second = (second < 10 ? '0' : '') + second;
  thisYear = new Date().getFullYear();
  year = (_ref = thisYear === year) != null ? _ref : {
    '': year + '-'
  };
  return year + month + '-' + day + ' ' + hour + ':' + minute;
};

exports.escape = function(html) {
  var blocks, codeBlock, codeSpan, spans, text;
  codeSpan = /(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm;
  codeBlock = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g;
  spans = [];
  blocks = [];
  text = String(html).replace(/\r\n/g, '\n').replace('/\r/g', '\n');
  text = '\n\n' + text + '\n\n';
  text = text.replace(codeSpan, function(code) {
    spans.push(code);
    return 'span';
  });
  text += '~0';
  return text.replace(codeBlock, function(whole, code, nextChar) {
    blocks.push(code);
    return '\n\tblock' + nextChar.replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/`span`/g, function() {
      return spans.shift();
    }).replace(/\n\tblock/g, function() {
      return blocks.shift();
    }).replace(/~0$/, '').replace(/^\n\n/, '').replace(/\n\n$/, '');
  });
};

exports.xss = function(html) {
  return xss(html);
};

exports.strim = function(str) {
  return sanitize(str).trim();
};

exports.recode = function() {
  return {
    recode: 200,
    reason: 'success'
  };
};

empty = function(str) {
  if (typeof str === 'undefined') {
    return true;
  }
  if (str === '') {
    return true;
  }
  if (str.length <= 0) {
    return true;
  }
  return false;
};

exports.empty = empty;

md5 = function(str) {
  var md5sum;
  md5sum = crypto.createHash('md5');
  md5sum.update(str);
  str = md5sum.digest('hex');
  return str;
};

exports.md5 = md5;

encrypt = function(str, secret) {
  var cipher, enc;
  cipher = crypto.createCipher('aes192', secret);
  enc = cipher.update(str, 'utf8', 'hex');
  enc += cipher.final('hex');
  return enc;
};

exports.encrypt = encrypt;

decrypt = function(str, secret) {
  var dec, decipher;
  decipher = crypto.createDecipher('aes192', secret);
  dec = decipher.update(str, 'hex', 'utf8');
  dec += decipher.final('utf8');
  return dec;
};

exports.decrypt = decrypt;

exports.gen_session = function(user, res) {
  var auth_token, day;
  auth_token = encrypt(user._id + '\t' + user.name + '\t' + user.pass + '\t' + user.email, config.session_secret);
  day = 1000 * 60 * 60 * 24 * 30;
  return res.cookie(config.auth_cookie_name, auth_token, {
    path: '/',
    maxAge: day
  });
};
